//////////////////////////////////////////////////
// Accessing tutorial structure pointers
//////////////////////////////////////////////////

// %action Get_Tut_Ptrs(av, bv, sv) {
//   %t "(" + av + ", " + bv + ") = (" + sv + "->tut_A, " + sv + "->tut_B)"
//   %f { E(s) (sv(s) & ga(s, v)), E(s) (sv(s) & gb(s, v)) }
//   %message !(E(s) sv(s)) ->
//            "" + sv + " points to NULL"
//   {
//     av(e) = (E(s) sv(s) & ga(s, e))
//     bv(e) = (E(s) sv(s) & gb(s, e))
//     // TODO: Get depth information from sv.
//   }
// }

%action Get_Tut_Ptr_A(v, sv) {
  %t v + " = " + sv + "->tut_A"
  %f { E(s, v_1) (sv(s) & ga(s, v_1) & t[n](v_1, v)) }
  %message !(E(s) sv(s)) ->
           "" + sv + " points to NULL"
  // %message (E(s) sv(s)) & !(E(s, e) sv(s) & ga(s, e)) ->
  //          s + "->tut_A is NULL"
  {
    v(e) = E(s) (sv(s) & ga(s, e))
  }
}

%action Get_Tut_Ptr_B(v, sv) {
  %t v + " = " + sv + "->tut_B"
  %f { E(s, v_1) (sv(s) & gb(s, v_1) & t[n](v_1, v)) }
  %message !(E(s) sv(s)) ->
           "" + sv + " points to NULL"
  // %message (E(s) sv(s)) & !(E(s, e) sv(s) & gb(s, e)) ->
  //          s + "->tut_A is NULL"
  {
    v(e) = E(s) (sv(s) & gb(s, e))
  }
}

//////////////////////////////////////////////////
// Structure pointer sets
//////////////////////////////////////////////////

%action Set_Tut_Ptr_A(sv, lv) {
  %t sv + "->tut_A = " + lv
  {
    ga(s, e) = (sv(s) ? lv(e) : ga(s, e))
  }
}


%action Set_Tut_Ptr_B(sv, lv) {
  %t sv + "->tut_B = " + lv
  {
    gb(s, e) = (sv(s) ? lv(e) : gb(s, e))
  }
}

//////////////////////////////////////////////////
// NULL sets
//////////////////////////////////////////////////

%action Set_Tut_Ptr_A_Null(sv) {
  %t sv + "->tut_A = NULL"
  {
    ga(s, e) = !sv(s) & ga(s, e)
  }
}


%action Set_Tut_Ptr_B_Null(sv) {
  %t sv + "->tut_B = NULL"
  {
    gb(s, e) = !sv(s) & gb(s, e)
  }
}

//////////////////////////////////////////////////
// Variable NULL checks
//////////////////////////////////////////////////

%action Is_Not_Null_Var(var) {
  %t var + " != NULL"
  %f { var(v) } 
  %p E(v) var(v)
}

%action Is_Null_Var(var) {
  %t var + " == NULL"
  %f { var(v) } 
  %p !(E(v) var(v))
}

%action Set_Null(var) {
  %t var + " = NULL"
  {
    var(v) = 0
  }
}

//////////////////////////////////////////////////
// student_id related
//////////////////////////////////////////////////

%action Is_Student_Id(var) {
  %t var + "->studentID == studentID"
  %f { E(e) (var(e) & stud_id(e)) }
  %p (E(e) (var(e) & stud_id(e)))
}

%action Is_Not_Student_Id(var) {
  %t var + "->studentID != studentID"
  %f { E(e) (var(e) & stud_id(e)) }
  %p !(E(e) (var(e) & stud_id(e)))
}

//////////////////////////////////////////////////
// next pointer related
//////////////////////////////////////////////////

%action Advance_Next(var) {
  %t var + " = " + var + "->next"
  %f { E(e_1, e_2) (var(e_1) & n(e_1, e_2) & t[n](e_2, v)) }
  {
    var(e) = E(e_1) var(e_1) & n(e_1, e)
    // TODO: Change depth.
  }
}

//////////////////////////////////////////////////
// Memory management
//////////////////////////////////////////////////

%action Malloc_Tutorial(var) {
  %t var + " = malloc(sizeof(struct bintut))"
  %new
  {
    var(e) = isNew(e)
    le(e) = le(e) & !isNew(e)
    ts(e) = ts(e) | isNew(e)
  }
}

%action Malloc_Student(var) {
  %t var + " = malloc(sizeof(struct list_el))"
  %new
  {
    var(e) = isNew(e)
    le(e) = le(e) | isNew(e)
    ts(e) = ts(e) & !isNew(e)
  }
}

//////////////////////////////////////////////////
// Auxiliary
//////////////////////////////////////////////////

%action skip() {
  %t "skip"
}

//////////////////////////////////////////////////
// create related assertions
//////////////////////////////////////////////////

%action Assert_Correct_Create(sv) {
  %t "Assert_Correct_Create(" + sv + ")"
  %p !((E(s) (sv(s) & ts(s) & !(E(n) (ga(s, n) | gb(s, n))))) &
       (A(s) sv(s)))
}

//////////////////////////////////////////////////
// search related assertions
//////////////////////////////////////////////////

%action Assert_Correct_Search(v, sv) {
  %t "Assert_Correct_Search(" + v + ", " + sv + ")"
  %p (E(n) res(n)) &
     !(E(s, n1, n2) (v(n1) & sv(s) & res(n2) &
                     ((ga(s, n1) & r[n,ga](s, n2)) |
                      (gb(s, n1) & r[n,gb](s, n2)))))
}
